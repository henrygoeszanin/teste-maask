# Fluxo Completo da Aplica√ß√£o - Arquitetura Simplificada

## üìã √çndice

1. [Vis√£o Geral](#vis√£o-geral)
2. [Fluxo de Autentica√ß√£o](#fluxo-de-autentica√ß√£o)
3. [Fluxo de Registro de Dispositivo](#fluxo-de-registro-de-dispositivo)
4. [Fluxo de Upload de Arquivo](#fluxo-de-upload-de-arquivo)
5. [Fluxo de Download de Arquivo](#fluxo-de-download-de-arquivo)
6. [Fluxo de Revoga√ß√£o de Dispositivos](#fluxo-de-revoga√ß√£o-de-dispositivos)

---

## Vis√£o Geral

O sistema implementa **criptografia de arquivos** para upload e download de perfis de navegador. Os dados s√£o criptografados no cliente antes de serem enviados ao servidor. A chave de criptografia √© gerada pelo servidor no momento do cadastro do usu√°rio e disponibilizada para qualquer dispositivo autenticado.

### Componentes Principais

```
Cliente (Browser/App)
    ‚Üì
API Backend (Fastify)
    ‚Üì
Banco de Dados (PostgreSQL) - Metadados + chave de criptografia
    ‚Üì
Supabase Storage - Arquivos criptografados
```

### Conceitos de Criptografia

1. **criptografyCode** - Chave de criptografia do usu√°rio

   - Gerada automaticamente pelo servidor no cadastro (string aleat√≥ria)
   - Armazenada criptografada no banco de dados
   - Retornada para o cliente ap√≥s autentica√ß√£o
   - Usada para criptografar/descriptografar todos os arquivos do usu√°rio

2. **Dispositivos** - Identificadores simples

   - Cada dispositivo tem um `deviceName` √∫nico
   - N√£o h√° chaves p√∫blicas/privadas RSA
   - Controle de acesso baseado em status (active/inactive/revoked)

3. **Arquivos** - Dados criptografados no cliente
   - Cliente usa `criptografyCode` para criptografar arquivos antes do upload
   - Servidor armazena apenas metadados (nome, tamanho, caminho)
   - Cliente usa `criptografyCode` para descriptografar ap√≥s download

---

## Fluxo de Autentica√ß√£o

### 1. Registro de Usu√°rio

```javascript
// No Cliente
const response = await fetch("/api/users", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: "Jo√£o Silva",
    email: "joao@email.com",
    password: "Senha123!",
  }),
});

const user = await response.json();
console.log("Usu√°rio cadastrado:", user);
// {
//   id: "01HX...",
//   name: "Jo√£o Silva",
//   email: "joao@email.com",
//   criptografyCode: "a1b2c3d4e5f6..."  // ‚≠ê Chave para criptografia
//   createdAt: "2025-10-14T12:00:00Z"
// }

// ‚ö†Ô∏è IMPORTANTE: Armazene a chave localmente
localStorage.setItem("criptografyCode", user.criptografyCode);
```

**Servidor processa:**

```
Cliente ‚Üí API: POST /api/users
Body: {
  "name": "Jo√£o Silva",
  "email": "joao@email.com",
  "password": "Senha123!"
}

API processa:
1. Valida dados com Zod (user.dto.ts)
2. Hash da senha com Argon2 (pepper + salt)
3. Gera criptografyCode (crypto.randomBytes(32).toString('hex'))
4. Cria entidade User (User.ts)
5. Salva no banco via UserRepository

Response: {
  id: "01HX...",
  name: "Jo√£o Silva",
  email: "joao@email.com",
  criptografyCode: "a1b2c3d4e5f6...",
  createdAt: "2025-10-14T12:00:00Z"
}
```

**Caminho no c√≥digo:**

```
user.routes.ts (POST /)
  ‚Üí validateBody(RegisterSchema)
  ‚Üí UserController.create()
    ‚Üí RegisterUseCase.execute()
      ‚Üí User.create() // Gera criptografyCode automaticamente
      ‚Üí UserRepository.create()
        ‚Üí PostgreSQL (users table)
```

---

### 2. Login

```javascript
// No Cliente
const response = await fetch("/api/login", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    email: "joao@email.com",
    password: "Senha123!",
  }),
});

const data = await response.json();
console.log("Login realizado:", data);
// {
//   accessToken: "eyJhbGc...",
//   refreshToken: "eyJhbGc...",
//   user: {
//     id: "01HX...",
//     name: "Jo√£o Silva",
//     email: "joao@email.com",
//     criptografyCode: "a1b2c3d4e5f6..."  // ‚≠ê Chave para criptografia
//   }
// }

// ‚ö†Ô∏è IMPORTANTE: Armazene os tokens e a chave
localStorage.setItem("accessToken", data.accessToken);
localStorage.setItem("refreshToken", data.refreshToken);
localStorage.setItem("criptografyCode", data.user.criptografyCode);
```

**Servidor processa:**

```
Cliente ‚Üí API: POST /api/login
Body: {
  "email": "joao@email.com",
  "password": "Senha123!"
}

API processa:
1. Busca usu√°rio por email
2. Verifica senha com Argon2
3. Gera JWT (accessToken + refreshToken)
4. Retorna tokens + dados do usu√°rio (incluindo criptografyCode)

Response: {
  accessToken: "eyJhbGc...",
  refreshToken: "eyJhbGc...",
  user: {
    id: "01HX...",
    name: "Jo√£o Silva",
    email: "joao@email.com",
    criptografyCode: "a1b2c3d4e5f6..."
  }
}
```

**Caminho no c√≥digo:**

```
auth.routes.ts (POST /login)
  ‚Üí validateBody(LoginSchema)
  ‚Üí AuthController.login()
    ‚Üí LoginUseCase.execute()
      ‚Üí UserRepository.findByEmail()
      ‚Üí Argon2.verify()
      ‚Üí JWT.sign()
      ‚Üí Retorna user com criptografyCode
```

---

### 3. Recuperar Dados do Usu√°rio

```javascript
// No Cliente - Ao iniciar a aplica√ß√£o
const accessToken = localStorage.getItem("accessToken");
let criptografyCode = localStorage.getItem("criptografyCode");

if (!criptografyCode) {
  // Se n√£o tem localmente, busca do servidor
  const response = await fetch("/api/users/me", {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });

  const { data } = await response.json();
  criptografyCode = data.criptografyCode;

  // Armazena localmente
  localStorage.setItem("criptografyCode", criptografyCode);
}

console.log("‚úÖ Chave de criptografia carregada");
```

**Servidor processa:**

```
Cliente ‚Üí API: GET /api/users/me
Headers: {
  "Authorization": "Bearer eyJhbGc..."
}

API processa:
1. Autentica usu√°rio (JWT middleware)
2. Busca dados do usu√°rio no banco
3. Retorna dados incluindo criptografyCode

Response: {
  data: {
    id: "01HX...",
    name: "Jo√£o Silva",
    email: "joao@email.com",
    criptografyCode: "a1b2c3d4e5f6..."
  }
}
```

**Caminho no c√≥digo:**

```
user.routes.ts (GET /me)
  ‚Üí preHandler: authenticate
  ‚Üí UserController.getMe()
    ‚Üí UserRepository.findById()
      ‚Üí PostgreSQL (users table)
```

---

## Fluxo de Registro de Dispositivo

```javascript
// No Cliente

// Gera um nome √∫nico para o dispositivo
const deviceName = `${navigator.platform}-${Date.now()}`;
// Exemplo: "Win32-1697289600000"

const response = await fetch("/api/devices", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${accessToken}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    deviceName: deviceName,
  }),
});

const device = await response.json();
console.log("‚úÖ Dispositivo registrado:", device);
// {
//   id: "01HX...",
//   deviceName: "Win32-1697289600000",
//   status: "active",
//   createdAt: "2025-10-14T12:00:00Z"
// }

// Armazena deviceName localmente
localStorage.setItem("deviceName", deviceName);
```

**Servidor processa:**

```
Cliente ‚Üí API: POST /api/devices
Headers: {
  "Authorization": "Bearer eyJhbGc..."
}
Body: {
  "deviceName": "Win32-1697289600000"
}

API processa:
1. Autentica usu√°rio (JWT)
2. Valida dados com Zod
3. Verifica se deviceName j√° existe
4. Cria entidade Device (status: active)
5. Salva no banco

Response: {
  id: "01HX...",
  deviceName: "Win32-1697289600000",
  status: "active",
  createdAt: "2025-10-14T12:00:00Z"
}
```

**Caminho no c√≥digo:**

```
device.routes.ts (POST /devices)
  ‚Üí preHandler: authenticate
  ‚Üí validateBody(RegisterDeviceSchema)
  ‚Üí DeviceController.register()
    ‚Üí RegisterDeviceUseCase.execute()
      ‚Üí DeviceRepository.findByDeviceName() // Verifica duplicata
      ‚Üí Device.create()
      ‚Üí DeviceRepository.create()
        ‚Üí PostgreSQL (devices table)
```

---

## Fluxo de Upload de Arquivo

### Fase 1: Iniciar Upload

```javascript
// No Cliente
const file = document.getElementById("file-input").files[0];

// 1. Solicita URL assinada ao servidor
const initResponse = await fetch("/api/files/upload/init", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${accessToken}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    fileName: file.name,
    fileSize: file.size,
    mimeType: file.type,
  }),
});

const { data } = await initResponse.json();
const { uploadId, fileId, presignedUrl, expiresIn } = data;

console.log("‚úÖ Upload iniciado:", { uploadId, fileId });
```

**Servidor processa:**

```
Cliente ‚Üí API: POST /api/files/upload/init
Headers: {
  "Authorization": "Bearer eyJhbGc..."
}
Body: {
  "fileName": "perfil-chrome.zip",
  "fileSize": 52428800,  // 50MB
  "mimeType": "application/zip"
}

API processa:
1. Autentica usu√°rio
2. Valida dados (max 500MB)
3. Gera uploadId (ULID)
4. Gera fileId (UUID)
5. Gera caminho no Storage: users/{userId}/files/{fileId}
6. Gera presigned URL (v√°lida por 1 hora)

Response: {
  data: {
    uploadId: "01HX...",
    fileId: "a1b2c3d4-...",
    presignedUrl: "https://...supabase.co/storage/v1/object/upload/...",
    expiresIn: 3600
  }
}
```

**Caminho no c√≥digo:**

```
file.routes.ts (POST /files/upload/init)
  ‚Üí preHandler: authenticate
  ‚Üí validateBody(InitUploadSchema)
  ‚Üí FileController.initUpload()
    ‚Üí InitUploadUseCase.execute()
      ‚Üí SupabaseStorageService.generateFileKey()
      ‚Üí SupabaseStorageService.generatePresignedUploadUrl()
```

---

### Fase 2: Criptografar e Enviar Arquivo

```javascript
// No Cliente

// 2. Recupera a chave de criptografia do usu√°rio
const criptografyCode = localStorage.getItem("criptografyCode");

if (!criptografyCode) {
  throw new Error("Chave de criptografia n√£o encontrada");
}

// 3. Converte criptografyCode para chave AES-GCM
const encoder = new TextEncoder();
const keyMaterial = encoder.encode(criptografyCode);

// Hash da chave para obter 256 bits
const keyHash = await crypto.subtle.digest("SHA-256", keyMaterial);

// Importa como chave AES-GCM
const cryptoKey = await crypto.subtle.importKey(
  "raw",
  keyHash,
  { name: "AES-GCM" },
  false,
  ["encrypt"]
);

// 4. Gera IV aleat√≥rio para este arquivo
const iv = crypto.getRandomValues(new Uint8Array(12)); // 96 bits para GCM

// 5. Criptografa arquivo
const fileArrayBuffer = await file.arrayBuffer();
const encryptedData = await crypto.subtle.encrypt(
  {
    name: "AES-GCM",
    iv: iv,
  },
  cryptoKey,
  fileArrayBuffer
);

// 6. Combina IV + dados criptografados
// (IV precisa estar junto para descriptografia posterior)
const combined = new Uint8Array(iv.length + encryptedData.byteLength);
combined.set(iv, 0);
combined.set(new Uint8Array(encryptedData), iv.length);

// 7. Upload para Supabase Storage usando presigned URL
const uploadResponse = await fetch(presignedUrl, {
  method: "PUT",
  body: combined,
  headers: {
    "Content-Type": "application/octet-stream",
  },
});

if (!uploadResponse.ok) {
  throw new Error("Upload falhou");
}

console.log("‚úÖ Arquivo criptografado e enviado com sucesso!");
```

---

### Fase 3: Completar Upload

```javascript
// No Cliente (continua√ß√£o)

// 8. Notifica servidor que upload est√° completo
const completeResponse = await fetch("/api/files/upload/complete", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${accessToken}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    uploadId: uploadId,
    fileId: fileId,
    fileName: file.name,
    fileSize: file.size,
  }),
});

const result = await completeResponse.json();
console.log("‚úÖ Upload completo:", result);
// {
//   message: "Upload completado com sucesso",
//   data: {
//     fileId: "a1b2c3d4-...",
//     fileName: "perfil-chrome.zip",
//     sizeBytes: 52428800,
//     uploadedAt: "2025-10-14T12:05:00Z"
//   }
// }
```

**Servidor processa:**

```
Cliente ‚Üí API: POST /api/files/upload/complete
Headers: {
  "Authorization": "Bearer eyJhbGc..."
}
Body: {
  "uploadId": "01HX...",
  "fileId": "a1b2c3d4-...",
  "fileName": "perfil-chrome.zip",
  "fileSize": 52428800
}

API processa:
1. Autentica usu√°rio
2. Valida dados com Zod
3. Verifica se arquivo existe no Supabase Storage
4. Cria entidade File (apenas metadados)
5. Salva no banco

Response: {
  message: "Upload completado com sucesso",
  data: {
    fileId: "a1b2c3d4-...",
    fileName: "perfil-chrome.zip",
    sizeBytes: 52428800,
    uploadedAt: "2025-10-14T12:05:00Z"
  }
}
```

**Caminho no c√≥digo:**

```
file.routes.ts (POST /files/upload/complete)
  ‚Üí preHandler: authenticate
  ‚Üí validateBody(CompleteUploadSchema)
  ‚Üí FileController.completeUpload()
    ‚Üí CompleteUploadUseCase.execute()
      ‚Üí SupabaseStorageService.fileExists()
      ‚Üí File.create()
      ‚Üí FileRepository.create()
        ‚Üí PostgreSQL (files table)
```

---

## Fluxo de Download de Arquivo

### Fase 1: Solicitar Download

```javascript
// No Cliente

// 1. Lista arquivos dispon√≠veis
const listResponse = await fetch("/api/files?page=1&limit=20", {
  headers: {
    Authorization: `Bearer ${accessToken}`,
  },
});

const { data } = await listResponse.json();
console.log("Arquivos dispon√≠veis:", data.files);
// [
//   {
//     fileId: "a1b2c3d4-...",
//     fileName: "perfil-chrome.zip",
//     sizeBytes: 52428800,
//     createdAt: "2025-10-14T12:05:00Z"
//   }
// ]

// 2. Solicita download de um arquivo espec√≠fico
const fileId = data.files[0].fileId;
const downloadResponse = await fetch(`/api/files/${fileId}/download`, {
  headers: {
    Authorization: `Bearer ${accessToken}`,
  },
});

const downloadData = await downloadResponse.json();
const {
  fileId: downloadFileId,
  fileName,
  presignedUrl,
  expiresIn,
} = downloadData.data;

console.log("‚úÖ URL de download obtida");
```

**Servidor processa:**

```
Cliente ‚Üí API: GET /api/files/{fileId}/download
Headers: {
  "Authorization": "Bearer eyJhbGc..."
}

API processa:
1. Autentica usu√°rio
2. Busca arquivo no banco por fileId
3. Verifica se arquivo pertence ao usu√°rio
4. Verifica se arquivo existe no Supabase Storage
5. Gera presigned URL para download (1 hora)
6. Retorna metadados + presigned URL

Response: {
  data: {
    fileId: "a1b2c3d4-...",
    fileName: "perfil-chrome.zip",
    presignedUrl: "https://...supabase.co/storage/v1/object/sign/...",
    expiresIn: 3600
  }
}
```

**Caminho no c√≥digo:**

```
file.routes.ts (GET /files/:fileId/download)
  ‚Üí preHandler: authenticate
  ‚Üí FileController.download()
    ‚Üí DownloadFileUseCase.execute()
      ‚Üí FileRepository.findByFileId()
      ‚Üí SupabaseStorageService.fileExists()
      ‚Üí SupabaseStorageService.generatePresignedDownloadUrl()
```

---

### Fase 2: Baixar e Descriptografar

```javascript
// No Cliente (continua√ß√£o)

// 3. Download do arquivo criptografado do Supabase Storage
const fileResponse = await fetch(presignedUrl);
const encryptedFileBuffer = await fileResponse.arrayBuffer();

console.log("‚úÖ Arquivo criptografado baixado");

// 4. Recupera a chave de criptografia do usu√°rio
const criptografyCode = localStorage.getItem("criptografyCode");

if (!criptografyCode) {
  throw new Error("Chave de criptografia n√£o encontrada");
}

// 5. Converte criptografyCode para chave AES-GCM
const encoder = new TextEncoder();
const keyMaterial = encoder.encode(criptografyCode);

// Hash da chave para obter 256 bits
const keyHash = await crypto.subtle.digest("SHA-256", keyMaterial);

// Importa como chave AES-GCM
const cryptoKey = await crypto.subtle.importKey(
  "raw",
  keyHash,
  { name: "AES-GCM" },
  false,
  ["decrypt"]
);

// 6. Extrai IV (primeiros 12 bytes) e dados criptografados
const combined = new Uint8Array(encryptedFileBuffer);
const iv = combined.slice(0, 12);
const encryptedData = combined.slice(12);

console.log("‚úÖ IV extra√≠do, iniciando descriptografia");

// 7. Descriptografa arquivo
const decryptedBuffer = await crypto.subtle.decrypt(
  {
    name: "AES-GCM",
    iv: iv,
  },
  cryptoKey,
  encryptedData
);

console.log("‚úÖ Arquivo descriptografado");

// 8. Cria blob e faz download
const blob = new Blob([decryptedBuffer], { type: "application/zip" });
const url = URL.createObjectURL(blob);
const a = document.createElement("a");
a.href = url;
a.download = fileName;
a.click();
URL.revokeObjectURL(url);

console.log("‚úÖ Download completo!");
```

---

## Fluxo de Revoga√ß√£o de Dispositivos

### Cen√°rio: Usu√°rio perde um dispositivo

```javascript
// No Cliente - Dispositivo principal (Laptop)

// 1. Lista todos os dispositivos
const response = await fetch("/api/devices", {
  headers: {
    Authorization: `Bearer ${accessToken}`,
  },
});

const { devices } = await response.json();
console.log("Dispositivos:", devices);
// [
//   { id: "1", deviceName: "Win32-1697289600000", status: "active" },
//   { id: "2", deviceName: "iPhone-1697289700000", status: "active" },
// ]

// 2. Usu√°rio identifica dispositivo perdido
const deviceToRevoke = devices.find((d) =>
  d.deviceName.includes("iPhone-1697289700000")
);

// 3. Confirma revoga√ß√£o
const confirmed = confirm(
  `‚ö†Ô∏è ATEN√á√ÉO: Revogar dispositivo ${deviceToRevoke.deviceName}?\n\n` +
    `Este dispositivo ser√° marcado como "revoked" e perder√° acesso √† API.\n` +
    `Para restaurar o acesso, ser√° necess√°rio fazer login novamente.`
);

if (!confirmed) {
  console.log("‚ùå Revoga√ß√£o cancelada");
  return;
}

// 4. Revoga o dispositivo
const currentDeviceName = localStorage.getItem("deviceName");

const revokeResponse = await fetch("/api/devices/revoke", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${accessToken}`,
    "X-Device-Name": currentDeviceName, // Dispositivo que est√° revogando
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    deviceName: deviceToRevoke.deviceName,
    password: "Senha123!", // Senha obrigat√≥ria
    reason: "lost",
  }),
});

if (revokeResponse.ok) {
  console.log("‚úÖ Dispositivo revogado com sucesso!");
  alert("Dispositivo revogado! Ele n√£o poder√° mais fazer login.");
} else {
  const error = await revokeResponse.json();
  console.error("‚ùå Erro ao revogar:", error);
}
```

**Servidor processa:**

```
Cliente ‚Üí API: POST /api/devices/revoke
Headers: {
  "Authorization": "Bearer eyJhbGc...",
  "X-Device-Name": "Win32-1697289600000"
}
Body: {
  "deviceName": "iPhone-1697289700000",
  "password": "Senha123!",
  "reason": "lost"
}

API processa:
1. Autentica usu√°rio (JWT)
2. Valida X-Device-Name header
3. Busca dispositivo atual (quem est√° revogando)
4. Verifica se dispositivo atual est√° ativo
5. Busca dispositivo alvo (a ser revogado)
6. Valida senha do usu√°rio com Argon2
7. Verifica se n√£o est√° tentando revogar a si mesmo
8. Marca dispositivo como "revoked"
9. Atualiza no banco

Response: {
  message: "Device revoked successfully",
  data: {
    deviceName: "iPhone-1697289700000",
    revokedAt: "2025-10-14T10:35:00Z"
  }
}
```

**Caminho no c√≥digo:**

```
device.routes.ts (POST /devices/revoke)
  ‚Üí preHandler: authenticate
  ‚Üí validateBody(RevokeDeviceSchema)
  ‚Üí DeviceRevocationController.revokeDevice()
    ‚Üí RevokeDeviceUseCase.execute()
      ‚Üí UserRepository.findById() // Valida senha
      ‚Üí Argon2.verify()
      ‚Üí DeviceRepository.findByDeviceName() // Dispositivo atual
      ‚Üí DeviceRepository.findByDeviceName() // Dispositivo alvo
      ‚Üí device.revoke() // Marca como revoked
      ‚Üí DeviceRepository.update()
        ‚Üí PostgreSQL (devices table)
```

---

### Estado do Banco Ap√≥s Revoga√ß√£o

**Antes da Revoga√ß√£o:**

```sql
-- Tabela devices
id | user_id | device_name           | status   | created_at          | updated_at
---+---------+-----------------------+----------+---------------------+---------------------
1  | user-1  | Win32-1697289600000   | active   | 2025-10-14 10:00:00 | 2025-10-14 10:00:00
2  | user-1  | iPhone-1697289700000  | active   | 2025-10-14 10:05:00 | 2025-10-14 10:05:00
```

**Depois da Revoga√ß√£o:**

```sql
-- Tabela devices
id | user_id | device_name           | status   | created_at          | updated_at
---+---------+-----------------------+----------+---------------------+---------------------
1  | user-1  | Win32-1697289600000   | active   | 2025-10-14 10:00:00 | 2025-10-14 10:00:00
2  | user-1  | iPhone-1697289700000  | revoked  | 2025-10-14 10:05:00 | 2025-10-14 10:35:00  ‚Üê REVOGADO
```

---

### üõ°Ô∏è Prote√ß√µes Implementadas

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ               PROTE√á√ïES DE SEGURAN√áA                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ 1Ô∏è‚É£ Senha Obrigat√≥ria                                        ‚îÇ
‚îÇ    ‚úÖ Argon2 com pepper                                     ‚îÇ
‚îÇ    ‚úÖ Valida√ß√£o no backend                                  ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ 2Ô∏è‚É£ Valida√ß√£o de Status                                      ‚îÇ
‚îÇ    ‚úÖ Sempre consulta banco de dados                        ‚îÇ
‚îÇ    ‚úÖ Dispositivo revogado = bloqueado                      ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ 3Ô∏è‚É£ Auto-Revoga√ß√£o Bloqueada                                 ‚îÇ
‚îÇ    ‚úÖ Dispositivo n√£o pode revogar a si mesmo               ‚îÇ
‚îÇ    ‚úÖ Requer outro dispositivo autorizado                   ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ 4Ô∏è‚É£ Valida√ß√£o de Propriedade                                 ‚îÇ
‚îÇ    ‚úÖ Apenas dono pode revogar dispositivos                 ‚îÇ
‚îÇ    ‚úÖ Verifica√ß√£o de userId                                 ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ 5Ô∏è‚É£ Auditoria                                                ‚îÇ
‚îÇ    ‚úÖ Registra quem, quando, por qu√™                        ‚îÇ
‚îÇ    ‚úÖ Timestamps de revoga√ß√£o                               ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

### Casos de Uso

#### Caso 1: Dispositivo Perdido/Roubado

```
Timeline:
10:00 - Usu√°rio perde celular (iPhone)
10:30 - Usu√°rio acessa laptop e revoga iPhone
10:31 - Sistema valida senha ‚úÖ
10:32 - iPhone marcado como "revoked" ‚úÖ

Resultado:
‚úÖ Laptop: Funcionando normalmente
‚ùå iPhone: N√£o pode mais fazer requisi√ß√µes √† API
```

#### Caso 2: Troca de Senha Adicional

```
Timeline:
10:00 - Usu√°rio revoga dispositivo
10:05 - Usu√°rio troca senha (RECOMENDADO)
10:06 - Todos os tokens JWT s√£o invalidados

Resultado:
‚ùå Dispositivo revogado: Sem acesso permanente
‚ùå Outros dispositivos: Precisam fazer login novamente
‚úÖ Seguran√ßa m√°xima garantida
```

---

## Resumo da Arquitetura

### Vantagens da Arquitetura Simplificada

‚úÖ **Simplicidade**

- Sem necessidade de sincroniza√ß√£o complexa de chaves
- Sem envelopes RSA
- Sem master devices

‚úÖ **Multi-dispositivo**

- Qualquer dispositivo autenticado acessa a mesma chave
- Login em novo dispositivo = acesso imediato aos arquivos
- Sem processo de "autoriza√ß√£o" entre dispositivos

‚úÖ **Recupera√ß√£o F√°cil**

- Perda de dispositivo n√£o impede acesso aos dados
- Basta fazer login em outro dispositivo

‚úÖ **Seguran√ßa Adequada**

- Arquivos criptografados com AES-256-GCM
- Chave armazenada criptografada no banco
- Controle de acesso via JWT e status de dispositivo

### Limita√ß√µes

‚ö†Ô∏è **Confian√ßa no Servidor**

- O servidor tem acesso √† `criptografyCode` (embora criptografada)
- N√£o √© zero-knowledge (servidor pode descriptografar se comprometido)

‚ö†Ô∏è **Revoga√ß√£o n√£o Imediata**

- Dispositivo revogado ainda pode acessar arquivos j√° baixados
- Apenas bloqueia novas requisi√ß√µes √† API

### Recomenda√ß√µes de Seguran√ßa

1. **Sempre use HTTPS** - Toda comunica√ß√£o deve ser criptografada
2. **Rota√ß√£o de chaves** - Considere permitir que usu√°rio regenere `criptografyCode`
3. **Auditoria** - Registre todos os acessos e a√ß√µes sens√≠veis
4. **Rate limiting** - Previna ataques de for√ßa bruta
5. **Troca de senha** - Ap√≥s revogar dispositivo, recomende troca de senha
